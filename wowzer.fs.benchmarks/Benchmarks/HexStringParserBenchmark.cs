using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using System.Text;
using BenchmarkDotNet.Attributes;

namespace wowzer.fs.benchmarks.Benchmarks {
    public class HexStringParserBenchmark {
        public IEnumerable<(string, byte[])> ArgumentsSource() {
            var asciiStringSource = new byte[200];
            new Random().NextBytes(asciiStringSource);
            var stringSource = Convert.ToHexString(asciiStringSource);

            yield return (stringSource, Encoding.UTF8.GetBytes(stringSource));
        }

        [Benchmark(Baseline = true), ArgumentsSource(nameof(ArgumentsSource))]
        public byte[] Baseline((string Arg, byte[]) args) => Convert.FromHexString(args.Arg.AsSpan());

        [Benchmark, ArgumentsSource(nameof(ArgumentsSource))]
        public byte[] VectorizedBytes((string, byte[] Arg) args) {

            ref var srcRef = ref MemoryMarshal.GetArrayDataReference(args.Arg);

            nuint offset = 0;

            var dst = GC.AllocateUninitializedArray<byte>(args.Arg.Length / 2);
            ref var dstRef = ref MemoryMarshal.GetArrayDataReference(dst);

            do {
                var vec = Vector128.LoadUnsafe(ref srcRef, offset);

                // Based on "Algorithm #3" https://github.com/WojciechMula/toys/blob/master/simd-parse-hex/geoff_algorithm.cpp
                var t1 = vec + Vector128.Create((byte) (0xFF - '9')); // Move digits '0'..'9' into range 0xF6..0xFF.
                var t2 = Ssse3.SubtractSaturate(t1, Vector128.Create((byte) 6));
                var t3 = Vector128.Subtract(t2, Vector128.Create((byte) 0xF0));
                var t4 = vec & Vector128.Create((byte) 0xDF);
                var t5 = t4 - Vector128.Create((byte) 'A');
                var t6 = Ssse3.AddSaturate(t5, Vector128.Create((byte) 10));

                var t7 = Vector128.Min(t3, t6);
                var t8 = Ssse3.AddSaturate(t7, Vector128.Create((byte) (127 - 15)));

                if (t8.ExtractMostSignificantBits() != 0)
                {
                    // Not valid hex
                    return [];
                }

                var t0 = Ssse3.MultiplyAddAdjacent(t7, Vector128.Create((short) 0x0110).AsSByte()).AsByte();
                var output = Vector128.Shuffle(t0,
                    Vector128.Create((byte)0, 2, 4, 6, 8, 10, 12, 14, 0, 0, 0, 0, 0, 0, 0, 0)
                    // Vector128.Create((byte) 14, 12, 10, 8, 6, 4, 2, 0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF)
                );

                Unsafe.WriteUnaligned(ref Unsafe.Add(ref dstRef, offset / 2), output.AsUInt64().ToScalar());

                offset += (nuint) Vector128<byte>.Count;
            }
            while (offset < (nuint) args.Arg.Length);

            /*for (; offset < (nuint) args.Arg.Length; ++offset) {
                var byteLo = Unsafe.Add(ref srcRef, offset) >> 4;
                var byteHi = Unsafe.Add(ref srcRef, offset) & 0xF;

                ref var target = ref Unsafe.Add(ref dstRef, offset / 2);
                target = (byte) ((byteHi << 4) | byteLo);
            }*/
            return dst;
        }

        /// <summary>Map from an ASCII char to its hex value, e.g. arr['b'] == 11. 0xFF means it's not a hex digit.</summary>
        public static ReadOnlySpan<byte> CharToHexLookup =>
        [
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 15
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 31
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 47
            0x0,  0x1,  0x2,  0x3,  0x4,  0x5,  0x6,  0x7,  0x8,  0x9,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 63
            0xFF, 0xA,  0xB,  0xC,  0xD,  0xE,  0xF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 79
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 95
            0xFF, 0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 111
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 127
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 143
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 159
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 175
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 191
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 207
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 223
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 239
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  // 255
        ];
    }
}